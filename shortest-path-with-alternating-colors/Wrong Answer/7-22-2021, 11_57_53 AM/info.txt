{"id":526405945,"lang":"cpp","time":"1 month, 3 weeks","timestamp":1626935273,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/526405945/","is_pending":"Not Pending","title":"Shortest Path with Alternating Colors","memory":"N/A","code":"#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\nstatic auto _ = []() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  return 0;\n}();\n\nclass Solution {\npublic:\n    \n    struct hash_pair {\n    template <class T1, class T2>\n    size_t operator()(const pair<T1, T2>& p) const\n        {\n            auto hash1 = hash<T1>{}(p.first);\n            auto hash2 = hash<T2>{}(p.second);\n            return hash1 ^ hash2;\n        }\n    };\n    \n    unordered_map<int, vector<int>>adjRed;\n    unordered_map<int, vector<int>>adjBlue;\n\n    int bfs(int &e,int& n)\n    {\n        if(e==0)return 0;\n        \n        queue<pair<int,char>>q;\n        unordered_map<pair<int,char>,bool,hash_pair>vis;\n        vector<int>dist(n,0);\n        dist[0]=0;\n        q.push({0,'N'});\n        \n        while(!q.empty())\n        {\n            pair<int,char>temp=q.front();\n            q.pop();\n            if(vis.find(temp)!=vis.end())continue;\n            if(temp.second=='N')\n            {\n                vis[{0,'B'}]=true;\n                vis[{0,'R'}]=true;\n            }\n            else\n            vis[temp]=true;\n            \n            if(temp.first==e)return dist[temp.first];\n            \n            if(temp.second=='N')\n            {\n                vector<int>candRed=adjRed[temp.first];\n                vector<int>candBlu=adjBlue[temp.first];\n                \n                for(int i=0;i<candBlu.size();i++)\n                {\n                    if(vis.find({candBlu[i],'B'})!=vis.end())continue;\n                    dist[candBlu[i]]=dist[temp.first]+1;\n                    q.push({candBlu[i],'B'});\n                }\n                \n                for(int i=0;i<candRed.size();i++)\n                {\n                    if(vis.find({candRed[i],'R'})!=vis.end())continue;\n                    dist[candRed[i]]=dist[temp.first]+1;\n                    q.push({candRed[i],'R'});\n                }\n            }\n            if(temp.second=='R')\n            {\n                vector<int>candBlu=adjBlue[temp.first];\n                for(int i=0;i<candBlu.size();i++)\n                {\n                    if(vis.find({candBlu[i],'B'})!=vis.end())continue;\n                    dist[candBlu[i]]=dist[temp.first]+1;\n                    q.push({candBlu[i],'B'});\n                }\n            }\n            if(temp.second=='B')\n            {\n                vector<int>candRed=adjRed[temp.first];\n                for(int i=0;i<candRed.size();i++)\n                {\n                    if(vis.find({candRed[i],'R'})!=vis.end())continue;\n                    dist[candRed[i]]=dist[temp.first]+1;\n                    q.push({candRed[i],'R'});\n                }\n            }\n            \n        }\n        return -1;\n    }\n\n    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& red_edges, vector<vector<int>>& blue_edges) {\n        vector<int>ans(n);\n        \n        for(int i=0;i<red_edges.size();i++)\n        adjRed[red_edges[i][0]].push_back(red_edges[i][1]);\n        \n        for(int i=0;i<blue_edges.size();i++)\n        adjBlue[blue_edges[i][0]].push_back(blue_edges[i][1]);\n        \n        for(int i=0;i<n;i++)\n        {\n            ans[i]=bfs(i,n);\n        }\n        return ans;\n    }\n};","compare_result":"111111111101111010111111110111000110111100000010000000111111110010110010100000100000000000","title_slug":"shortest-path-with-alternating-colors"}