{"id":527516797,"lang":"cpp","time":"1 month, 2 weeks","timestamp":1627132946,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/527516797/","is_pending":"Not Pending","title":"Minimum Genetic Mutation","memory":"N/A","code":"#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\nstatic auto _ = []() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  return 0;\n}();\n\nclass Solution {\npublic:\n    int minMutation(string start, string end, vector<string>& bank) {\n        unordered_set<string>valids;\n        \n        for(int i=0;i<bank.size();i++)\n        valids.insert(bank[i]);\n        \n        queue<string>q;\n        q.push(start);\n        int changes=0;\n        char words[4]={'A','C','T','G'};\n        while(!q.empty())\n        {\n            int len=q.size();\n            for(int k=0;k<len;k++)\n            {\n                string temp=q.front();\n                q.pop();\n                \n                for(int i=changes;i<temp.length();i++)\n                {\n                    for(int j=0;j<4;j++)\n                    {\n                        if(words[j]==temp[i])continue;\n                        char t=temp[i];\n                        temp[i]=words[j];\n                        if(valids.find(temp)!=valids.end())\n                        {\n                            if(temp==end)return changes+1;\n                            else\n                            q.push(temp);\n                        }\n                        temp[i]=t;\n                    }\n                }\n                \n            }\n            changes++;\n        }\n        return -1;\n    }\n};","compare_result":"11111111100100","title_slug":"minimum-genetic-mutation"}