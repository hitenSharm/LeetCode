{"id":532466438,"lang":"cpp","time":"1 month, 1 week","timestamp":1627966728,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/532466438/","is_pending":"Not Pending","title":"Flip Binary Tree To Match Preorder Traversal","memory":"13.8 MB","code":"#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\nstatic auto _ = []() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  return 0;\n}();\n\nclass Solution {\npublic:\n\n    int index=0;\n\n    bool dfs(TreeNode* root,vector<int>& ans,vector<int>& path)\n    {\n       if(!root || index>=path.size())return true;\n       if(root->val!=path[index])return false;\n       if(index+1<path.size() and root->left and root->left->val!=path[index+1])\n       {\n           if(root->right and root->right->val!=path[index+1])return false;\n           ans.push_back(root->val);\n           TreeNode* temp=root->right;\n           root->right=root->left;\n           root->left=temp;\n       }\n       index++;\n       return (dfs(root->left,ans,path) and dfs(root->right,ans,path));\n    }\n\n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {\n        vector<int>ans;\n        if(!dfs(root,ans,voyage))return {-1};\n        return ans;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"flip-binary-tree-to-match-preorder-traversal"}