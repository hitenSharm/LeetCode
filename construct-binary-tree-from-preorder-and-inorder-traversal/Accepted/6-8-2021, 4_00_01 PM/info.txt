{"id":504870503,"lang":"cpp","time":"3Â months","timestamp":1623148201,"status_display":"Accepted","runtime":"28 ms","url":"/submissions/detail/504870503/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"26.5 MB","code":"#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\nstatic auto _ = []() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  return 0;\n}();\n\nclass Solution {\npublic:\n\n    int index=0;\n    unordered_map<int,int>ump;\n\n    TreeNode* recu(vector<int>& preorder,int l,int r)\n    {\n      if(l>r)\n        return NULL;\n      TreeNode* temp = new TreeNode(preorder[index]);      \n      index++;\n      if(l==r)\n        return temp;\n      int inOrederIndex=ump[temp->val];\n\n      temp->left=recu(preorder,l,inOrederIndex-1);\n      temp->right=recu(preorder,inOrederIndex+1,r);\n\n      return temp;\n    }\n    \n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        TreeNode* ans;\n        \n        for(int i=0;i<inorder.size();i++)\n          ump[inorder[i]]=i;\n\n        ans=recu(preorder,0,preorder.size()-1);\n        return ans;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}