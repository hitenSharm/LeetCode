{"id":506022008,"lang":"cpp","time":"3Â months","timestamp":1623347328,"status_display":"Accepted","runtime":"216 ms","url":"/submissions/detail/506022008/","is_pending":"Not Pending","title":"Find Eventual Safe States","memory":"47.8 MB","code":"#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\nstatic auto _ = []() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  return 0;\n}();\n\nclass Solution {\npublic:\n    vector<int>dp;\n    vector<int>vis;\n\n    int recu(vector<vector<int>>& graph,int index)\n    {      \n      if(index>=graph.size() || graph[index].size()==0)\n        return 0;\n      if(dp[index]!=-1)\n        return dp[index];\n      if(vis[index]==1)\n        return 1;\n      vis[index]=1;\n      int ans=0;\n      for(int i=0;i<graph[index].size();i++)\n      {\n        ans=max(ans,recu(graph,graph[index][i]));\n        if(ans==1)\n        {\n          return dp[index]=1;\n        }\n      }\n      return dp[index]=0;\n    }\n\n    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n        dp.resize(graph.size(),-1);\n        vis.resize(graph.size(),0);\n        vector<int>ans;\n        for(int i=0;i<graph.size();i++)\n        {\n          if(recu(graph,i)==0)\n            ans.push_back(i);\n        }\n        return ans;\n    }\n};\n\n\n\n\n// https://leetcode.com/problems/find-eventual-safe-states/","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-eventual-safe-states"}