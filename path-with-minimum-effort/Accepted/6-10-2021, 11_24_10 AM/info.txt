{"id":505780987,"lang":"cpp","time":"3Â months","timestamp":1623304450,"status_display":"Accepted","runtime":"528 ms","url":"/submissions/detail/505780987/","is_pending":"Not Pending","title":"Path With Minimum Effort","memory":"22.1 MB","code":"#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\nstatic auto _ = []() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  return 0;\n}();\n\nclass Solution {\npublic:\n    int minimumEffortPath(vector<vector<int>>& heights) {\n     int m = heights.size(), n = heights[0].size();\n     int dirs[5] = {-1, 0, 1, 0, -1};\n\n    vector<vector<int>> nodes(m, vector<int>(n, INT_MAX));\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> heap;\n\n    heap.emplace(0, 0);\n    while (!heap.empty()) {\n      int effort = heap.top().first;\n      int x = heap.top().second / 100, y = heap.top().second % 100;\n      heap.pop();\n\n      if (x == m - 1 && y == n - 1) return effort;\n      if (effort >= nodes[x][y]) continue;\n      nodes[x][y] = effort;\n\n      for (int i = 0; i < 4; i++) {\n        int nx = x + dirs[i], ny = y + dirs[i + 1];\n        if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;\n        int n_effort = max(effort, abs(heights[x][y] - heights[nx][ny]));\n        heap.emplace(n_effort, nx * 100 + ny);\n      }\n    }\n    return -1;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"path-with-minimum-effort"}