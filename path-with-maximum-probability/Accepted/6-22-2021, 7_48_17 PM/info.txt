{"id":511610199,"lang":"cpp","time":"2 months, 3 weeks","timestamp":1624371497,"status_display":"Accepted","runtime":"172 ms","url":"/submissions/detail/511610199/","is_pending":"Not Pending","title":"Path with Maximum Probability","memory":"70.4 MB","code":"#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\nstatic auto _ = []() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  return 0;\n}();\n\nclass Solution {\npublic:\n    \n    vector<int>vis;\n\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vis.resize(n,0);\n        unordered_map<int,vector<pair<int,double>>>adjList;\n        \n        for(int i=0;i<edges.size();i++)\n        {\n            adjList[edges[i][0]].push_back(make_pair(edges[i][1],succProb[i]));\n            adjList[edges[i][1]].push_back(make_pair(edges[i][0],succProb[i]));\n        }\n        priority_queue<pair<double,int>>pq;\n        pq.push({1,start});\n        vector<double>nodes(n,DBL_MIN);\n        nodes[start]=1;\n        while(!pq.empty())\n        {\n            start=pq.top().second;\n            double dist=pq.top().first;\n            pq.pop();\n            if(vis[start]==1)continue;\n            vis[start]=1;\n            vector<pair<int,double>>& candid=adjList[start];\n            for(int i=0;i<candid.size();i++)\n            {\n                double newDist=candid[i].second;\n                if(newDist * dist > nodes[candid[i].first])\n                {\n                    nodes[candid[i].first]=newDist * dist;\n                    pq.push({nodes[candid[i].first],candid[i].first});\n                }\n            }\n            if(start==end)\n            return nodes[start];\n        }\n        return 0;\n    }\n};","compare_result":"1111111111111111","title_slug":"path-with-maximum-probability"}